% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvlgcp.R
\name{mvlgcp}
\alias{mvlgcp}
\title{Main wrapper function for fitting uni- or multivariate, 2D spatial point process models via \code{glmmTMB}}
\usage{
mvlgcp(
  formula,
  data,
  weights = NULL,
  basis.functions,
  coord.names = c("x", "y"),
  response.id,
  bf.matrix.type = c("sparse", "dense"),
  n_factors = 2,
  mv.flds = c("both", "correlated", "independent"),
  ...
)
}
\arguments{
\item{formula}{a formula for the fixed & random effects, \emph{excluding} latent fields. The response of the formula must be a binary point event/quadrature identifier.}

\item{data}{a \code{data.frame} comprising of the response and predictors supplied within \code{formula}, as well as \code{coord.names}. The 'response' must be a binary that indicates whether a datum is a point event (1) or quadrature point (0) - see Dovers et al. 2024 for details.}

\item{weights}{a vector of quadrature weights with length equal to \code{nrow(data)} OR the name of the column within \code{data} where these can be found. These must be supplied for a point process model approximated in this way.}

\item{basis.functions}{a basis functions object. See \code{make_basis()}.}

\item{coord.names}{a vector of two character strings describing the column names of the coordinates (horizontal and vertical resp.) within \code{data}.}

\item{response.id}{a vector of length \code{nrow(data)} that categorises data into the various responses in the multivariate case.}

\item{bf.matrix.type}{a character string, one of \code{"sparse"} or \code{"dense"} indicating whether to use a sparse/dense matrix to represent the basis function approximation to the latent field(s). The default of \code{"sparse"} is usually preferred, although in some instances (e.g. with single-response TPRS basis) using a dense matrix may be more efficient.}

\item{n_factors}{an integer describing the number of latent factors to be used to characterise the multivariate latent fields within the multivariate log-Gaussian Cox process.}

\item{mv.flds}{a character string, one of \code{"both"}, \code{"correlated"}, or \code{"independent"}. Applies only to a mutlivariate LGCP and indicates whether to include: correlated latent fields (via the reduced rank approach when \code{= "correlated"}); independent latent fields (one for each response when \code{= "independent"}); or both correlated fields (via the reduced rank approach) and independent fields for each response (when \code{= "both"}). The latter is the default, allowing the correlated latent fields to capture shared spatial clustering only.}

\item{...}{other terms to be passed to \code{glmmTMB()}.}
}
\value{
a fitted \code{glmmTMB} model object with some additional list items, specific to the point process model.
}
\description{
This function acts as a wrapper for \code{glmmTMB()}, permitting the modelling point patterns (in two dimensions) as a log-Gaussian Cox process (or Poisson process) using a similar approach to Dovers et al. (2024). The appropriate likelihood(s) are approximated using the approach of Berman and Turner (1992). Latent field(s) included in the Cox process are approximated via spatial basis functions while multivariate versions involve an additional approximation using a factor-analytic approach.
}
\details{
An approximate log-Gaussian Cox process will be fitted to the data when \code{basis.functions} are supplied. Otherwise, a Poisson process framework is used.
Additionally if \code{response.id} is supplied a multivariate LGCP is fitted with \code{n_factor} independent latent fields that provide correlated, response-specific fields via factor loadings (using the existing \code{rr()} framework in \code{glmmTMB}).

Note that for a Poisson process \code{response.id} is not used and a multivariate form should be specified via the formula, e.g. \code{response ~ (1|response.id) + (0 + covariate|response.id)} will fit random intercepts and slopes (for the "\code{covariate}") according to \code{response.id}.

\code{basis.functions} should be an object created via \code{make_basis()} which currently supports those from \code{mgcv}, \code{FRK}, and \code{scampr} packages. There is scope to include any kind of basis functions, this would require writing an appropriate method within \code{bf_matrix()}.
}
\examples{
# using a subset of the Lansing Wood data:
dat1 <- lansing[lansing$tree == "blackoak", ]
dat2 <- lansing[lansing$tree \%in\% c("blackoak", "hickory", "maple"), ]
dat2$tree <- factor(as.character(dat2$tree)) # remove unused tree species

# set up the basis functions with dimension k = 100
bfs <- make_basis(k = 100, dat1)

# fit univariate LGCP to the blackoak point pattern data
m1 <- mvlgcp(pt ~ 1, data = dat1, weights = dat1$wt, basis.functions = bfs)
# fit a multivariate LGCP to the point patterns of "blackoak", "hickory" and "maple" trees
m2 <- mvlgcp(pt ~ (1 | tree), data = dat2, weights = dat2$wt, basis.functions = bfs, response.id = dat2$tree)

# compare the latent fields for blackoaks with/without accounting for between species correlations

# first we need to specify the domain (in this example the quadrature points of the data are a regular grid of the domain of interest)
domain <- dat1[dat1$pt == 0, ]

# extract the fields
fld1 <- get_field(m1, newdata = domain)
fld1_mv <- get_field(m2, newdata = domain, which.response = 1)
fld2_mv <- get_field(m2, newdata = domain, which.response = 2)
fld3_mv <- get_field(m2, newdata = domain, which.response = 3)

# plot the fields
par(mfrow = c(2, 2), mar = c(0,0,1,1.5))
plot(vec2im(fld1, domain$x, domain$y), main = "Univariate LGCP\nBlack Oak")
points(dat1[dat1$pt == 1, c("x", "y")])
plot(vec2im(fld1_mv, domain$x, domain$y), main = "Multivariate LGCP\nBlack Oak")
points(dat2[dat2$pt == 1 & dat2$tree == "blackoak", c("x", "y")])
plot(vec2im(fld2_mv, domain$x, domain$y), main = "Multivariate LGCP\nHickory")
points(dat2[dat2$pt == 1 & dat2$tree == "hickory", c("x", "y")], pch = 2)
plot(vec2im(fld3_mv, domain$x, domain$y), main = "Multivariate LGCP\nMaple")
points(dat2[dat2$pt == 1 & dat2$tree == "maple", c("x", "y")], pch = 3)
par(mfrow = c(1, 1), mar = c(5.1,4.1,4.1,2.1))
}
\references{
Berman, M. and Turner, T. R. (1992), Approximating Point Process Likelihoods with GLIM, \emph{Journal of the Royal Statistical Society. Series C} (Applied Statistics), \bold{41}, 31â€“38.

Dovers, E and Stoklosa, J and Warton, D. I. (2024) Fitting log-Gaussian Cox processes using generalized additive model software, \emph{The American Statistician}, DOI: 10.1080/00031305.2024.2316725
}
